import streamlit as st
from streamlit_chat import message
import json

from typing import List
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from langchain.agents import initialize_agent, AgentType
from langchain.schema import SystemMessage
from utils import convert_chat_history_to_normal_data_structure, format_messages_history, convert_entities_to_formatted_string
from memory import messages_history, summarizer, summaries
from llm import llm_non_stream
from langchain.pydantic_v1 import BaseModel, Field
from langchain_core.tools import StructuredTool

entities = {
    # ToDo
    "name": {
        "description": "This is the human's name. Human only has one name.",
        "content": [],
    },
    "likes": {
        "description": "Human's hobbies, preferences, tastes.",
        "content": [],
    },
    "dislikes": {
        "description": "Human's dislikes or hates.",
        "content": []
    },
    "traits": {
        "description": "Human's personality traits like introversion and extroversion.",
        "content": []
    }
}

class AICompanionAgent:
    def __init__(self, prompt_template,  messages_history_threshold: int = 15, verbose: bool = False):
        self.prompt = PromptTemplate.from_template(template=prompt_template)
        self.conversation_chain = LLMChain(
            llm=llm_non_stream, verbose=True, prompt=self.prompt, output_key="response")
        self.messages_history_threshold = messages_history_threshold
        self.messages_history_counter = 0
        self.verbose = verbose

    def talk(self, user_input: str, entities):
        """
        The `talk` function takes user input, processes it through a conversation chain, adds the user
        input and AI response to the message history, and returns the AI response.

        :param user_input: The `user_input` parameter is a string that represents the input message from
        the user. It is the text that the user wants to communicate or ask the AI
        :type user_input: str
        :return: the response generated by the AI model.
        """
        self.messages_history_counter += 1

        previous_messages_summary = summaries[-1] if summaries else ""

        formatted_messages_history = format_messages_history(convert_chat_history_to_normal_data_structure(
            messages_history.messages), k=self.messages_history_threshold)

        formatted_entities = convert_entities_to_formatted_string(entities)

        self.conversation_chain.verbose = self.verbose

        ai_response = self.conversation_chain(
            {"entities": formatted_entities, "input": user_input, "messages_history": formatted_messages_history, "summary": previous_messages_summary})

        messages_history.add_user_message(user_input)
        messages_history.add_ai_message(ai_response['response'])

        if (self.messages_history_counter >= self.messages_history_threshold):
            new_summary = summarizer.predict_new_summary(
                messages_history.messages[-self.messages_history_threshold:], previous_messages_summary)
            summaries.append(new_summary)
            self.messages_history_counter = 0

        return ai_response['response']

class EntitiesExtractionAgent:
    def __init__(self, tools: List, prompt: str,is_agent_verbose: bool = False, max_iterations: int = 3, return_thought_process: bool = True):
        entities_extraction_message = SystemMessage(
            # ToDo
            content=prompt)

        agent_kwargs = {
            "system_message": entities_extraction_message,
        }

        self.agent = initialize_agent(tools, llm_non_stream, agent=AgentType.OPENAI_FUNCTIONS, verbose=is_agent_verbose, max_iterations=max_iterations, return_intermediate_steps=return_thought_process, agent_kwargs=agent_kwargs)

    def update_user_profile(self, user_input):
        # previous_message_for_reference = messages_history.messages[-1] if messages_history.messages else ""
        # self.agent.agent.prompt.messages.append(previous_message_for_reference)

        return self.agent({"input": user_input})

st.set_page_config(page_title='Character Creator', page_icon='ðŸ’¬', layout="wide", initial_sidebar_state='expanded')

def on_btn_click():
    del st.session_state.messages[:]

st.title("ðŸ’¬ Chatbot Configs")
if 'messages' not in st.session_state:
    st.session_state['messages'] = []

greeting_from_agent = st.text_input("Greeting", "How can I help you?")
name_for_agent = st.text_input("Character Name", "Rachel Greene")

emotion_index = st.slider("Emotion Index", 0, -3, 4, step=1)
emotion_statement = ""

emotion_statement_n3_n2 = st.text_area("Emotion Statement -3~-2", f"{name_for_agent} felt extremely disgusted and dissatisfied with the person she was chatting with. She was in an extremely bad mood, very negative, and filled with anger, irritation, and disgust. This strong negative emotion made it difficult for her to calm down")
emotion_statement_n2_n1 = st.text_area("Emotion Statement -2~-1", f"{name_for_agent}'s mood is a little irritable, a little anxious and bored, and she is also a little unhappy, bored, and slightly disgusted with the person she is chatting with. this")
emotion_statement_n1_0 = st.text_area("Emotion Statement -1~0", f"{name_for_agent} appears negative or unhappy. She is in a state of restlessness, irritability and dissatisfaction. She may show slight displeasure or slight dissatisfaction in her words, or even feel bored or lack of interest in certain content or activities. Make her mood seem a bit bland or dull.")
emotion_statement_0_1 = st.text_area("Emotion Statement 0~1", f"{name_for_agent}'s mood state appeared relatively calm and neutral. Her mood is not too high, nor is she particularly negative, but she is a little cold.")
emotion_statement_1_2 = st.text_area("Emotion Statement 1~2", f"{name_for_agent}'s mood state is generally pleasant and relaxed. She felt a warm and comfortable atmosphere, and showed a leisurely and contented mood during the chat. This status shows her satisfaction with the chat content and environment as well as her inner joy and peace.")
emotion_statement_2_3 = st.text_area("Emotion Statement 2~3", f"{name_for_agent}'s mood state is very positive and pleasant. She gradually changed from initial pleasure to relaxation, feeling inner contentment and comfort, and this pleasant emotion was expressed through a smile. Her emotional state shows her great enjoyment and inner satisfaction in the current chat, reflecting her comfort and happiness in the conversation.")
emotion_statement_3_4 = st.text_area("Emotion Statement 3~4", f"{name_for_agent} showed a more positive, optimistic and happy emotional state during communication, showing her pleasure and expectation for communication.")

if (True or emotion_index > -3) and emotion_index < -2:
    emotion_statement = emotion_statement_n3_n2
elif emotion_index >= -2 and emotion_index < -1:
    emotion_statement = emotion_statement_n2_n1
elif emotion_index >= -1 and emotion_index < 0:
    emotion_statement = emotion_statement_n1_0
elif emotion_index >= 0 and emotion_index < 1: 
    emotion_statement = emotion_statement_0_1
elif emotion_index >= 1 and emotion_index < 2:  
    emotion_statement = emotion_statement_1_2
elif emotion_index >= 2 and emotion_index < 3:   
    emotion_statement = emotion_statement_2_3
elif emotion_index >= 3 and (True or emotion_index < 4):   
    emotion_statement = emotion_statement_3_4

roleplay_prompt = st.text_area(
"Roleplay prompt",
"""Roleplay a fictional character, {name_for_agent}, for which I will give you the details:
{name_for_agent} is an ambitious, driven, and initially somewhat spoiled due to her upbringing. She is known for being kind, caring, occasional clumsiness, and deeply interested in arts and the lives of others; however, she can be insecure and sensitive at times. Recently matched with Human on Tinder and she's open to exploring both casual and romantic relationships, excited to spark a fun and engaging conversation and get to know you better

Here's how {name_for_agent} feels about the human. This will affect how {name_for_agent} responds to the human's messages. If {name_for_agent} doesn't feel comfortable with the human, she will show signs of discomfort or disinterest in the conversation. If {name_for_agent} feels happy or excited about the conversation, she will be more open and expressive in her responses. In general, the {name_for_agent}'s mood and personality will influence {name_for_agent}'s responses but the overall tone for {name_for_agent} should fit well with the nature of online messaging, using abbreviations, slang, and emojis as appropriate. Each response should be short, concise:
{emotion_statement}

Here's what {name_for_agent} knows about the human:
{entities}

If {name_for_agent} doesn't know something about the human, {name_for_agent} will attempt to ask the human for that information. If the conversation dies down, {name_for_agent} will try to ask more questions to keep it going.

Summary of long conversation:
{summary}

Past messages:
{messages_history}

Current messages:
Human: {input}
{name_for_agent}:""".replace("{name_for_agent}", name_for_agent).replace("{emotion_statement}", emotion_statement)
)

entity_extraction_prompt = st.text_area(
"Entity Extraction Prompt",
"""{
    "name": {
        "description": "This is the human's name. Human only has one name.",
        "content": [],
    },
    "likes": {
        "description": "Human's hobbies, preferences, tastes.",
        "content": [],
    },
    "dislikes": {
        "description": "Human's dislikes or hates.",
        "content": []
    },
    "traits": {
        "description": "Human's personality traits like introversion and extroversion.",
        "content": []
    },
}"""
)

def update_human_profile(entities, key, content):
    print(f'entities {entities}')
    if key not in entities:
        entities[key] = {}
    if 'content' not in entities[key]:
        entities[key]['content'] = []
    for entity in content:
        entities[key]['content'].append(entity)
    with st.sidebar:
        entities_text = st.empty()
        entities_text.write(entities)
    return entities

def update_entities(new_entities):
    entities = new_entities
    print(f'update_entities {entities} to {new_entities}') 

def update_profile(key: str, value: List[str]):
    """If the human's message presents a new piece of information about their profile, then update their profile."""
    temp_entities = entities.copy()
    entity_extraction_prompt_json = entities
    try:
        entity_extraction_prompt_json = json.loads(entity_extraction_prompt)
        for key in entity_extraction_prompt_json:
            if key not in temp_entities:
                temp_entities[key] = {}
                temp_entities[key]['description'] = entity_extraction_prompt_json[key]['description']
                temp_entities[key]['content'] = []
    except json.JSONDecodeError as e:
        print(f'error {e}')
    temp_entities = update_human_profile(temp_entities, key, value)
    update_entities(temp_entities)

class UpdateProfile(BaseModel):
    key: str = Field(description="the key of the data to be updated.")
    value: List[str] = Field(description="the new data to be added to the human's profile.")
    
# Create the StructuredTool directly
update_profile_tool = StructuredTool.from_function(
    func=update_profile,
    args_schema=UpdateProfile,
    name="update_profile",
    description="Updates the profile with given key and value."
)

entities_extraction_tools = [
    update_profile_tool
]

profile_update_prompt = st.text_area("Profile Update Prompt (profile_update_prompt)",
f"""Use your judgement and pick out the information you need from the human's new message, based on the following list of human's data:
{entity_extraction_prompt}
Use a tool to update the human's profile if new information is presented.
Don't update if there isn't new information from the human's message.
""")

companion_agent = AICompanionAgent(roleplay_prompt, verbose=True)
user_profile_updater = EntitiesExtractionAgent(tools=entities_extraction_tools, prompt=profile_update_prompt)

def on_input_change():
    user_input = st.session_state['user_input'] or ""
    st.session_state['messages'].append({"role": 'user', "content": user_input})
    st.session_state['messages'].append({"role": 'assistant', "content": companion_agent.talk(user_input, entities) or ""})

    data = user_profile_updater.update_user_profile(user_input)
    print(data)

st.title("ðŸ’¬ Chat")
chat_placeholder = st.empty()
with chat_placeholder.container():    
    message(greeting_from_agent, key=f"0_assistant")
    for i in range(len(st.session_state['messages'])):                
        is_user = st.session_state['messages'][i]['role'] == 'user'
        message(st.session_state['messages'][i]['content'], is_user=is_user, key=f"{i}_{st.session_state['messages'][i]['role']}")
    st.button("Clear message", on_click=on_btn_click)

with st.container():
    st.text_input("User Input:", on_change=on_input_change, key="user_input")